{"total":4,"pageSize":10,"pageCount":1,"data":[{"title":"js笔记-3（函数、方法）","slug":"js笔记-3","date":"2022-07-15T03:18:14.000Z","updated":"2022-07-15T03:19:15.553Z","comments":true,"path":"api/articles/js笔记-3.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记-函数、方法\"><a href=\"#js笔记-函数、方法\" class=\"headerlink\" title=\"js笔记(函数、方法)\"></a>js笔记(函数、方法)</h1><h2 id=\"函数-function\"><a href=\"#函数-function\" class=\"headerlink\" title=\"函数 function\"></a>函数 function</h2><ol>\n<li><p>函数也是一个对象，使用typeof检查一个函数对象时，会返回function</p>\n</li>\n<li><p>创建一个函数对象</p>\n<ol>\n<li><p>可以将要封装的代码以字符串的形式传递给构造函数</p>\n</li>\n<li><p>封装到函数中的代码不会立即执行，会在函数调用的时候执行</p>\n</li>\n<li><p>调用函数 语法： 函数对象() <em>当调用函数时，函数中封装的代码会按照顺序执行</em> </p>\n</li>\n<li><p><em><strong>使用构造函数来创建一个函数</strong></em> </p>\n<ol>\n<li>语法： var 函数名 &#x3D; new function(“”);</li>\n<li>一般不用</li>\n</ol>\n</li>\n<li><p><em><strong>使用函数声明来创建一个函数</strong></em> </p>\n<ol>\n<li><p>语法： function 函数名([形参1，形参2…形参N]){</p>\n<p>​\t\t\t   \t\t语句…</p>\n<p>​\t\t\t  }</p>\n</li>\n</ol>\n</li>\n<li><p><em><strong>使用函数表达式来创建一个函数</strong></em> </p>\n<ol>\n<li><p>语法：var 函数名 &#x3D; function([形参1，形参2…形参N]){</p>\n<p>​\t\t\t\t\t\t语句…</p>\n<p>​             };</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>function()</p>\n<ol>\n<li>调用函数</li>\n<li>相当于使用的函数的返回值</li>\n</ol>\n</li>\n<li><p>function</p>\n<ol>\n<li>函数对象</li>\n<li>相当于直接使用函数对象</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><ol>\n<li>作用域指一个变量的作用的范围</li>\n<li>在JS中一共有两种作用域</li>\n<li>全局作用域<ol>\n<li>直接编写在script标签中的JS代码，都在全局作用域</li>\n<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>\n<li>在全局作用于中有一个全局对象window<ol>\n<li>它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用</li>\n</ol>\n</li>\n<li>在全局作用域中<ol>\n<li>创建的变量都会作为window对象的属性保存</li>\n<li>创建的函数都会作为window对象的方法保存</li>\n</ol>\n</li>\n<li>全局作用域中的变量都是全局变量<ol>\n<li>在页面的任意的部分都可以访问到</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>函数作用域<ol>\n<li>调用函数时创建函数作用域，函数执行完毕后函数作用域销毁</li>\n<li>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</li>\n<li>在函数作用域中可以访问到全局作用域的变量<ol>\n<li>在全局作用域中无法访问到函数作用域的变量</li>\n</ol>\n</li>\n<li>当在函数作用域操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用<ol>\n<li>如果没有则向上一级作用域中寻找，直到找到全局作用域</li>\n<li>如果全局作用域中依然没有找到，则会报错ReferenceError</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"声明提前\"><a href=\"#声明提前\" class=\"headerlink\" title=\"声明提前\"></a>声明提前</h2><ol>\n<li>变量的声明提前<ol>\n<li>使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不适用var关键字，则变量不会被声明提前</li>\n</ol>\n</li>\n<li>函数的声明提前<ol>\n<li>使用函数声明形式创建的函数function 函数(){} 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用函数</li>\n<li>使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><ol>\n<li>构造函数和普通函数的区别就是调用方法的不同<ol>\n<li>普通函数是直接调用，构造函数需要使用new关键字来调用</li>\n</ol>\n</li>\n<li>构造函数的执行过程<ol>\n<li>立刻创建一个新的对象</li>\n<li>将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象</li>\n<li>逐行执行函数中的代码</li>\n<li>将新建的对象作为返回值返回</li>\n</ol>\n</li>\n<li>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个<em>类</em> 。我们将通过一个构造函数创建的对象，称为是该类的<em>实例</em> 。</li>\n<li>this的情况<ol>\n<li>当以函数的形式调用时，this是window</li>\n<li>当以方法的形式调用时，谁调用方法this就是谁</li>\n<li>当以构造函数的形式调用时，this就是新创建的那个实例</li>\n</ol>\n</li>\n<li>使用instanceof可以检查一个对象是否是一个类的实例<ol>\n<li>语法：对象 instanceof 构造函数</li>\n<li>如果是则返回true，否则返回false</li>\n<li>所有的对象都是Object的后代，任何对象和Object在instanceof检查时都会返回true</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":3,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":3,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"}]},{"title":"js笔记-2（对象）","slug":"js笔记-2","date":"2022-07-14T07:42:34.000Z","updated":"2022-07-15T03:20:46.029Z","comments":true,"path":"api/articles/js笔记-2.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（对象）\"><a href=\"#js笔记（对象）\" class=\"headerlink\" title=\"js笔记（对象）\"></a>js笔记（对象）</h1><h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><ol>\n<li>prompt()可以弹出一个提示框，该提示框中会带有一个文本框，用户可以在文本框中输入一段内容，并将内容赋值给变量。</li>\n</ol>\n<hr>\n<h2 id=\"对象的分类\"><a href=\"#对象的分类\" class=\"headerlink\" title=\"对象的分类\"></a>对象的分类</h2><ol>\n<li>内建对象<ol>\n<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>\n<li>比如：Math String Number Boolean Function Object..</li>\n</ol>\n</li>\n<li>宿主对象<ol>\n<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li>\n<li>比如：BOM DOM</li>\n</ol>\n</li>\n<li>自定义对象<ol>\n<li>由开发人员自己创建的对象</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ol>\n<li>var obj &#x3D; new Object();<ol>\n<li>使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数</li>\n<li>使用typeof检查一个对象时，会返回object</li>\n<li>在对象中保存的值称为属性</li>\n</ol>\n</li>\n<li>向对象中添加属性<ol>\n<li>语法：对象.属性名 &#x3D; 属性值</li>\n</ol>\n</li>\n<li>读取对象中的属性<ol>\n<li>语法：对象.属性名</li>\n<li><em>如果读取对象中没有的属性，不会报错而是会返回undefined</em></li>\n</ol>\n</li>\n<li>修改对象的属性值<ol>\n<li>语法：对象.属性名 &#x3D; 新值</li>\n</ol>\n</li>\n<li>删除对象的属性<ol>\n<li>语法：delete 对象.属性名</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"属性名和属性值\"><a href=\"#属性名和属性值\" class=\"headerlink\" title=\"属性名和属性值\"></a>属性名和属性值</h2><ol>\n<li>属性名<ol>\n<li>对象的属性名不强制要求遵守标识符的规范</li>\n<li>如果要使用特殊的属性名，不能采用.的方式来操作。语法：对象[“属性名”] &#x3D; 属性值</li>\n<li>使用[]这种形式去操作属性更加灵活，在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性</li>\n</ol>\n</li>\n<li>属性值<ol>\n<li>JS对象的属性值可以是任意的数据类型，甚至也可以是object</li>\n<li>in 运算符<ol>\n<li>通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true，没有则返回false</li>\n<li>语法： “属性名”   in   对象</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":3,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":3,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"}]},{"title":"js笔记-1（基本语法、运算符）","slug":"js笔记-1","date":"2022-07-13T07:03:29.000Z","updated":"2022-07-15T03:22:30.996Z","comments":true,"path":"api/articles/js笔记-1.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（基本语法、运算符）\"><a href=\"#js笔记（基本语法、运算符）\" class=\"headerlink\" title=\"js笔记（基本语法、运算符）\"></a>js笔记（基本语法、运算符）</h1><h2 id=\"基本语法一\"><a href=\"#基本语法一\" class=\"headerlink\" title=\"基本语法一\"></a>基本语法一</h2><ol>\n<li>console.log(“ “)</li>\n<li>document.write(“ “);</li>\n<li>var</li>\n<li>alert( );</li>\n<li>typeof  </li>\n<li>Infinity：number类型，表示无穷</li>\n</ol>\n<h2 id=\"基本语法二\"><a href=\"#基本语法二\" class=\"headerlink\" title=\"基本语法二\"></a>基本语法二</h2><ol>\n<li>转为String<ol>\n<li>a &#x3D; a.toString();<ol>\n<li>null和undefined无此方法</li>\n</ol>\n</li>\n<li>a &#x3D; String( a );<ol>\n<li>null和undefined可以使用此方法</li>\n<li>转为number</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>转为number<ol>\n<li>a &#x3D; Number( a );<ol>\n<li>字符串转数字<ol>\n<li>数字内容可以直接转换，非数字内容转换成NaN；</li>\n<li>内容为空或空格，则转换成0；</li>\n</ol>\n</li>\n<li>布尔转数字<ol>\n<li>true转为1</li>\n<li>false转为0</li>\n</ol>\n</li>\n<li>null和undefined<ol>\n<li>null转为0</li>\n<li>undefined转为NaN</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>a &#x3D; parseInt( a );<ol>\n<li>把字符串转为整数<ol>\n<li>从前往后读到非整数为止</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>a &#x3D; parseFloat( a );<ol>\n<li>把字符串转为浮点数</li>\n<li>和parseInt类似，不同的是可以取得小数位</li>\n</ol>\n</li>\n<li>其他进制<ol>\n<li>如需表示16进制数字，则以0x开头</li>\n<li>如需表示8进制数字，则以0开头</li>\n<li>如需表示2进制数字，则以0b开头  <strong>但不是所有浏览器都支持</strong></li>\n<li>可以在parseInt中传递第二个参数，来表示进制</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>转为boolean<ol>\n<li>a &#x3D; Boolean( a );</li>\n<li>数字转布尔<ol>\n<li>除了0和NaN，其余都是true</li>\n</ol>\n</li>\n<li>字符串转布尔<ol>\n<li>除了空串，其余都是true</li>\n</ol>\n</li>\n<li>null和undefined都是false</li>\n<li>对象也会转换为true</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><ol>\n<li>对非number进行运算时，会将他们转换为number进行运算<ol>\n<li>任何值和NaN做运算都得NaN</li>\n<li>true&#x3D;1，false&#x3D;0；</li>\n</ol>\n</li>\n<li>+ </li>\n<li>可以对两个值进行加法运算，并将结果返回</li>\n<li>如果对两个字符串进行加法运算，则会做拼串</li>\n<li>任何值和字符串相加，都会先转换成字符串，再拼串</li>\n<li>可以通过一个number+””，将其转为String</li>\n<li>- </li>\n<li>可以对两个值进行减法运算，并将结果返回</li>\n<li>无论和谁都转为number</li>\n<li>可以通过一个String-0，将其转为number</li>\n<li>* </li>\n<li>可以对两个值进行乘法运算，并将结果返回</li>\n<li>\\ </li>\n<li>可以对两个值进行除法运算，并将结果返回</li>\n<li>3&#x2F;2&#x3D;1.5（不会固定为整型）</li>\n<li>%</li>\n<li>可以对两个值进行取模运算，并将结果返回</li>\n</ol>\n<hr>\n<h2 id=\"一元运算符\"><a href=\"#一元运算符\" class=\"headerlink\" title=\"一元运算符\"></a>一元运算符</h2><ol>\n<li><p>一元运算符，只需要一个操作数</p>\n<ol>\n<li><p>+ 正号</p>\n<ol>\n<li>正号不会对数字产生任何影响</li>\n</ol>\n</li>\n<li><p>- 负号</p>\n<ol>\n<li>负号可以对数字进行负号的取反</li>\n</ol>\n</li>\n<li><p>对于非number类型的值</p>\n<ol>\n<li><p>他会先将其转为number，然后再运算</p>\n</li>\n<li><p>可以对一个其他的数据类型使用+，来将其转换为number，原理同Number()</p>\n<ol>\n<li>例：var result &#x3D; 1 + +”2” + 3;\t结果为6</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>非布尔值的与或运算</p>\n<ol>\n<li>与运算<ol>\n<li>如果两个值都为true，则返回后面的</li>\n<li>如果两个值中有false，则返回靠前的false</li>\n<li><em><strong>如果第一个值是 true，则必然返回第二个值；如果第一个值是 false，则必然返回第一个值</strong></em></li>\n<li>返回原值</li>\n</ol>\n</li>\n<li>或运算<ol>\n<li>如果第一个值为true，则直接返回第一个值</li>\n<li>如果第一个值为false，则直接返回第二个值</li>\n<li>返回原值</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>非数值的情况</p>\n<ol>\n<li>对于非数值进行比较时，会将其转换为数值再比较</li>\n<li>任何值和NaN做任何比较都是false</li>\n<li><strong>特殊：</strong> 如果符号两侧的值都是字符串，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode编码<ol>\n<li>比较字符编码时是一位一位进行比较，如果两位一样则比较下一位</li>\n<li>如果需要获取正确的结果，可以将其中一个String转为Number（在String前加上+）</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"Unicode编码\"><a href=\"#Unicode编码\" class=\"headerlink\" title=\"Unicode编码\"></a>Unicode编码</h2><ol>\n<li>在js中用 <strong>“&#x2F;u加上四位编码”</strong> </li>\n<li>在网页中用 **&amp;#加上四位编码; ** 需要将原Unicode（16进制）转为10进制</li>\n</ol>\n<hr>\n<h2 id=\"相等运算符\"><a href=\"#相等运算符\" class=\"headerlink\" title=\"相等运算符\"></a>相等运算符</h2><ol>\n<li>使用&#x3D;&#x3D; 来做相等运算时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再进行比较</li>\n<li>undefined衍生自null，这两个值做相等判断时，会返回true</li>\n<li>NaN不和任何值相等，包括他本身<ol>\n<li>可用 isNaN()函数来判断一个值是否是NaN，是则返回true</li>\n</ol>\n</li>\n<li><strong>&#x3D;&#x3D;&#x3D;</strong>  全等、 <strong>！&#x3D;&#x3D;</strong>  不全等 既判断值，也判断类型</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":3,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":3,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"}]},{"title":"poem","slug":"poem","date":"2022-03-03T04:00:00.000Z","updated":"2022-07-13T07:11:44.684Z","comments":true,"path":"api/articles/poem.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"一片落叶，一片冰心，一片浮梁好梦\"><a href=\"#一片落叶，一片冰心，一片浮梁好梦\" class=\"headerlink\" title=\"一片落叶，一片冰心，一片浮梁好梦\"></a><center>一片落叶，一片冰心，一片浮梁好梦</center></h2><h2 id=\"一弯寒月，一弯断肠，一弯颦蹙相逢\"><a href=\"#一弯寒月，一弯断肠，一弯颦蹙相逢\" class=\"headerlink\" title=\"一弯寒月，一弯断肠，一弯颦蹙相逢\"></a><center>一弯寒月，一弯断肠，一弯颦蹙相逢</center></h2>","link":"","raw":null,"photos":[],"categories":[{"name":"随感","slug":"随感","count":1,"path":"api/categories/随感.json"}],"tags":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/tags/Hexo.json"},{"name":"博客","slug":"博客","count":1,"path":"api/tags/博客.json"}]}]}