{"title":"js笔记-3（函数、方法）","slug":"js笔记-3","date":"2022-07-15T03:18:14.000Z","updated":"2022-07-15T03:19:15.553Z","comments":true,"path":"api/articles/js笔记-3.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"js笔记-函数、方法\"><a href=\"#js笔记-函数、方法\" class=\"headerlink\" title=\"js笔记(函数、方法)\"></a>js笔记(函数、方法)</h1><h2 id=\"函数-function\"><a href=\"#函数-function\" class=\"headerlink\" title=\"函数 function\"></a>函数 function</h2><ol>\n<li><p>函数也是一个对象，使用typeof检查一个函数对象时，会返回function</p>\n</li>\n<li><p>创建一个函数对象</p>\n<ol>\n<li><p>可以将要封装的代码以字符串的形式传递给构造函数</p>\n</li>\n<li><p>封装到函数中的代码不会立即执行，会在函数调用的时候执行</p>\n</li>\n<li><p>调用函数 语法： 函数对象() <em>当调用函数时，函数中封装的代码会按照顺序执行</em> </p>\n</li>\n<li><p><em><strong>使用构造函数来创建一个函数</strong></em> </p>\n<ol>\n<li>语法： var 函数名 &#x3D; new function(“”);</li>\n<li>一般不用</li>\n</ol>\n</li>\n<li><p><em><strong>使用函数声明来创建一个函数</strong></em> </p>\n<ol>\n<li><p>语法： function 函数名([形参1，形参2…形参N]){</p>\n<p>​\t\t\t   \t\t语句…</p>\n<p>​\t\t\t  }</p>\n</li>\n</ol>\n</li>\n<li><p><em><strong>使用函数表达式来创建一个函数</strong></em> </p>\n<ol>\n<li><p>语法：var 函数名 &#x3D; function([形参1，形参2…形参N]){</p>\n<p>​\t\t\t\t\t\t语句…</p>\n<p>​             };</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>function()</p>\n<ol>\n<li>调用函数</li>\n<li>相当于使用的函数的返回值</li>\n</ol>\n</li>\n<li><p>function</p>\n<ol>\n<li>函数对象</li>\n<li>相当于直接使用函数对象</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><ol>\n<li>作用域指一个变量的作用的范围</li>\n<li>在JS中一共有两种作用域</li>\n<li>全局作用域<ol>\n<li>直接编写在script标签中的JS代码，都在全局作用域</li>\n<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>\n<li>在全局作用于中有一个全局对象window<ol>\n<li>它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用</li>\n</ol>\n</li>\n<li>在全局作用域中<ol>\n<li>创建的变量都会作为window对象的属性保存</li>\n<li>创建的函数都会作为window对象的方法保存</li>\n</ol>\n</li>\n<li>全局作用域中的变量都是全局变量<ol>\n<li>在页面的任意的部分都可以访问到</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>函数作用域<ol>\n<li>调用函数时创建函数作用域，函数执行完毕后函数作用域销毁</li>\n<li>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</li>\n<li>在函数作用域中可以访问到全局作用域的变量<ol>\n<li>在全局作用域中无法访问到函数作用域的变量</li>\n</ol>\n</li>\n<li>当在函数作用域操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用<ol>\n<li>如果没有则向上一级作用域中寻找，直到找到全局作用域</li>\n<li>如果全局作用域中依然没有找到，则会报错ReferenceError</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"声明提前\"><a href=\"#声明提前\" class=\"headerlink\" title=\"声明提前\"></a>声明提前</h2><ol>\n<li>变量的声明提前<ol>\n<li>使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不适用var关键字，则变量不会被声明提前</li>\n</ol>\n</li>\n<li>函数的声明提前<ol>\n<li>使用函数声明形式创建的函数function 函数(){} 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用函数</li>\n<li>使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><ol>\n<li>构造函数和普通函数的区别就是调用方法的不同<ol>\n<li>普通函数是直接调用，构造函数需要使用new关键字来调用</li>\n</ol>\n</li>\n<li>构造函数的执行过程<ol>\n<li>立刻创建一个新的对象</li>\n<li>将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象</li>\n<li>逐行执行函数中的代码</li>\n<li>将新建的对象作为返回值返回</li>\n</ol>\n</li>\n<li>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个<em>类</em> 。我们将通过一个构造函数创建的对象，称为是该类的<em>实例</em> 。</li>\n<li>this的情况<ol>\n<li>当以函数的形式调用时，this是window</li>\n<li>当以方法的形式调用时，谁调用方法this就是谁</li>\n<li>当以构造函数的形式调用时，this就是新创建的那个实例</li>\n</ol>\n</li>\n<li>使用instanceof可以检查一个对象是否是一个类的实例<ol>\n<li>语法：对象 instanceof 构造函数</li>\n<li>如果是则返回true，否则返回false</li>\n<li>所有的对象都是Object的后代，任何对象和Object在instanceof检查时都会返回true</li>\n</ol>\n</li>\n</ol>\n","categories":[{"name":"笔记","slug":"笔记","count":3,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":3,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"}]}