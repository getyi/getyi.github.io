{"name":"js笔记","slug":"笔记/js笔记","count":7,"postlist":[{"title":"js笔记-1（基本语法、运算符）","slug":"js笔记-1","date":"2022-07-13T07:03:29.000Z","updated":"2022-07-26T07:02:44.431Z","comments":true,"path":"api/articles/js笔记-1.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（基本语法、运算符）\"><a href=\"#js笔记（基本语法、运算符）\" class=\"headerlink\" title=\"js笔记（基本语法、运算符）\"></a>js笔记（基本语法、运算符）</h1><h2 id=\"基本语法一\"><a href=\"#基本语法一\" class=\"headerlink\" title=\"基本语法一\"></a>基本语法一</h2><ol>\n<li>console.log(“ “)</li>\n<li>document.write(“ “);</li>\n<li>var</li>\n<li>alert( );</li>\n<li>typeof  </li>\n<li>Infinity：number类型，表示无穷</li>\n</ol>\n<h2 id=\"基本语法二\"><a href=\"#基本语法二\" class=\"headerlink\" title=\"基本语法二\"></a>基本语法二</h2><ol>\n<li>转为String<ol>\n<li>a &#x3D; a.toString();<ol>\n<li>null和undefined无此方法</li>\n</ol>\n</li>\n<li>a &#x3D; String( a );<ol>\n<li>null和undefined可以使用此方法</li>\n<li>转为number</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>转为number<ol>\n<li>a &#x3D; Number( a );<ol>\n<li>字符串转数字<ol>\n<li>数字内容可以直接转换，非数字内容转换成NaN；</li>\n<li>内容为空或空格，则转换成0；</li>\n</ol>\n</li>\n<li>布尔转数字<ol>\n<li>true转为1</li>\n<li>false转为0</li>\n</ol>\n</li>\n<li>null和undefined<ol>\n<li>null转为0</li>\n<li>undefined转为NaN</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>a &#x3D; parseInt( a );<ol>\n<li>把字符串转为整数<ol>\n<li>从前往后读到非整数为止</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>a &#x3D; parseFloat( a );<ol>\n<li>把字符串转为浮点数</li>\n<li>和parseInt类似，不同的是可以取得小数位</li>\n</ol>\n</li>\n<li>其他进制<ol>\n<li>如需表示16进制数字，则以0x开头</li>\n<li>如需表示8进制数字，则以0开头</li>\n<li>如需表示2进制数字，则以0b开头  <strong>但不是所有浏览器都支持</strong></li>\n<li>可以在parseInt中传递第二个参数，来表示进制</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>转为boolean<ol>\n<li>a &#x3D; Boolean( a );</li>\n<li>数字转布尔<ol>\n<li>除了0和NaN，其余都是true</li>\n</ol>\n</li>\n<li>字符串转布尔<ol>\n<li>除了空串，其余都是true</li>\n</ol>\n</li>\n<li>null和undefined都是false</li>\n<li>对象也会转换为true</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><ol>\n<li>对非number进行运算时，会将他们转换为number进行运算<ol>\n<li>任何值和NaN做运算都得NaN</li>\n<li>true&#x3D;1，false&#x3D;0；</li>\n</ol>\n</li>\n<li>+ <ol>\n<li>可以对两个值进行加法运算，并将结果返回</li>\n<li>如果对两个字符串进行加法运算，则会做拼串</li>\n<li>任何值和字符串相加，都会先转换成字符串，再拼串</li>\n<li>可以通过一个number+””，将其转为String</li>\n</ol>\n</li>\n<li>- <ol>\n<li>可以对两个值进行减法运算，并将结果返回</li>\n<li>无论和谁都转为number</li>\n<li>可以通过一个String-0，将其转为number</li>\n</ol>\n</li>\n<li>* <ol>\n<li>可以对两个值进行乘法运算，并将结果返回</li>\n</ol>\n</li>\n<li>\\ <ol>\n<li>可以对两个值进行除法运算，并将结果返回</li>\n<li>3&#x2F;2&#x3D;1.5（不会固定为整型）</li>\n</ol>\n</li>\n<li>%<ol>\n<li>可以对两个值进行取模运算，并将结果返回</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"一元运算符\"><a href=\"#一元运算符\" class=\"headerlink\" title=\"一元运算符\"></a>一元运算符</h2><ol>\n<li><p>一元运算符，只需要一个操作数</p>\n<ol>\n<li><p>+ 正号</p>\n<ol>\n<li>正号不会对数字产生任何影响</li>\n</ol>\n</li>\n<li><p>- 负号</p>\n<ol>\n<li>负号可以对数字进行负号的取反</li>\n</ol>\n</li>\n<li><p>对于非number类型的值</p>\n<ol>\n<li><p>他会先将其转为number，然后再运算</p>\n</li>\n<li><p>可以对一个其他的数据类型使用+，来将其转换为number，原理同Number()</p>\n<ol>\n<li>例：var result &#x3D; 1 + +”2” + 3;    结果为6</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>非布尔值的与或运算</p>\n<ol>\n<li>与运算<ol>\n<li>如果两个值都为true，则返回后面的</li>\n<li>如果两个值中有false，则返回靠前的false</li>\n<li><em><strong>如果第一个值是 true，则必然返回第二个值；如果第一个值是 false，则必然返回第一个值</strong></em></li>\n<li>返回原值</li>\n</ol>\n</li>\n<li>或运算<ol>\n<li>如果第一个值为true，则直接返回第一个值</li>\n<li>如果第一个值为false，则直接返回第二个值</li>\n<li>返回原值</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>非数值的情况</p>\n<ol>\n<li>对于非数值进行比较时，会将其转换为数值再比较</li>\n<li>任何值和NaN做任何比较都是false</li>\n<li><strong>特殊：</strong> 如果符号两侧的值都是字符串，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode编码<ol>\n<li>比较字符编码时是一位一位进行比较，如果两位一样则比较下一位</li>\n<li>如果需要获取正确的结果，可以将其中一个String转为Number（在String前加上+）</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"Unicode编码\"><a href=\"#Unicode编码\" class=\"headerlink\" title=\"Unicode编码\"></a>Unicode编码</h2><ol>\n<li>在js中用 <strong>“&#x2F;u加上四位编码”</strong> </li>\n<li>在网页中用 **&amp;#加上四位编码; ** 需要将原Unicode（16进制）转为10进制</li>\n</ol>\n<hr>\n<h2 id=\"相等运算符\"><a href=\"#相等运算符\" class=\"headerlink\" title=\"相等运算符\"></a>相等运算符</h2><ol>\n<li>使用&#x3D;&#x3D; 来做相等运算时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再进行比较</li>\n<li>undefined衍生自null，这两个值做相等判断时，会返回true</li>\n<li>NaN不和任何值相等，包括他本身<ol>\n<li>可用 isNaN()函数来判断一个值是否是NaN，是则返回true</li>\n</ol>\n</li>\n<li><strong>&#x3D;&#x3D;&#x3D;</strong>  全等、 <strong>！&#x3D;&#x3D;</strong>  不全等 既判断值，也判断类型</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]},{"title":"js笔记-3（函数、方法）","slug":"js笔记-3","date":"2022-07-15T03:18:14.000Z","updated":"2022-07-26T07:03:03.426Z","comments":true,"path":"api/articles/js笔记-3.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记-函数、方法\"><a href=\"#js笔记-函数、方法\" class=\"headerlink\" title=\"js笔记(函数、方法)\"></a>js笔记(函数、方法)</h1><h2 id=\"函数-function\"><a href=\"#函数-function\" class=\"headerlink\" title=\"函数 function\"></a>函数 function</h2><ol>\n<li><p>函数也是一个对象，使用typeof检查一个函数对象时，会返回function</p>\n</li>\n<li><p>创建一个函数对象</p>\n<ol>\n<li><p>可以将要封装的代码以字符串的形式传递给构造函数</p>\n</li>\n<li><p>封装到函数中的代码不会立即执行，会在函数调用的时候执行</p>\n</li>\n<li><p>调用函数 语法： 函数对象() <em>当调用函数时，函数中封装的代码会按照顺序执行</em> </p>\n</li>\n<li><p><em><strong>使用构造函数来创建一个函数</strong></em> </p>\n<ol>\n<li>语法： var 函数名 &#x3D; new function(“”);</li>\n<li>一般不用</li>\n</ol>\n</li>\n<li><p><em><strong>使用函数声明来创建一个函数</strong></em> </p>\n<ol>\n<li><p>语法： function 函数名([形参1，形参2…形参N]){</p>\n<p>​                       语句…</p>\n<p>​              }</p>\n</li>\n</ol>\n</li>\n<li><p><em><strong>使用函数表达式来创建一个函数</strong></em> </p>\n<ol>\n<li><p>语法：var 函数名 &#x3D; function([形参1，形参2…形参N]){</p>\n<p>​                        语句…</p>\n<p>​             };</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>function()</p>\n<ol>\n<li>调用函数</li>\n<li>相当于使用的函数的返回值</li>\n</ol>\n</li>\n<li><p>function</p>\n<ol>\n<li>函数对象</li>\n<li>相当于直接使用函数对象</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><ol>\n<li>作用域指一个变量的作用的范围</li>\n<li>在JS中一共有两种作用域</li>\n<li>全局作用域<ol>\n<li>直接编写在script标签中的JS代码，都在全局作用域</li>\n<li>全局作用域在页面打开时创建，在页面关闭时销毁</li>\n<li>在全局作用于中有一个全局对象window<ol>\n<li>它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用</li>\n</ol>\n</li>\n<li>在全局作用域中<ol>\n<li>创建的变量都会作为window对象的属性保存</li>\n<li>创建的函数都会作为window对象的方法保存</li>\n</ol>\n</li>\n<li>全局作用域中的变量都是全局变量<ol>\n<li>在页面的任意的部分都可以访问到</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>函数作用域<ol>\n<li>调用函数时创建函数作用域，函数执行完毕后函数作用域销毁</li>\n<li>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</li>\n<li>在函数作用域中可以访问到全局作用域的变量<ol>\n<li>在全局作用域中无法访问到函数作用域的变量</li>\n</ol>\n</li>\n<li>当在函数作用域操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用<ol>\n<li>如果没有则向上一级作用域中寻找，直到找到全局作用域</li>\n<li>如果全局作用域中依然没有找到，则会报错ReferenceError</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"声明提前\"><a href=\"#声明提前\" class=\"headerlink\" title=\"声明提前\"></a>声明提前</h2><ol>\n<li>变量的声明提前<ol>\n<li>使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不适用var关键字，则变量不会被声明提前</li>\n</ol>\n</li>\n<li>函数的声明提前<ol>\n<li>使用函数声明形式创建的函数function 函数(){} 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用函数</li>\n<li>使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><ol>\n<li>构造函数和普通函数的区别就是调用方法的不同<ol>\n<li>普通函数是直接调用，构造函数需要使用new关键字来调用</li>\n</ol>\n</li>\n<li>构造函数的执行过程<ol>\n<li>立刻创建一个新的对象</li>\n<li>将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象</li>\n<li>逐行执行函数中的代码</li>\n<li>将新建的对象作为返回值返回</li>\n</ol>\n</li>\n<li>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个<em>类</em> 。我们将通过一个构造函数创建的对象，称为是该类的<em>实例</em> 。</li>\n<li>this的情况<ol>\n<li>当以函数的形式调用时，this是window</li>\n<li>当以方法的形式调用时，谁调用方法this就是谁</li>\n<li>当以构造函数的形式调用时，this就是新创建的那个实例</li>\n</ol>\n</li>\n<li>使用instanceof可以检查一个对象是否是一个类的实例<ol>\n<li>语法：对象 instanceof 构造函数</li>\n<li>如果是则返回true，否则返回false</li>\n<li>所有的对象都是Object的后代，任何对象和Object在instanceof检查时都会返回true</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]},{"title":"js笔记-2（对象）","slug":"js笔记-2","date":"2022-07-14T07:42:34.000Z","updated":"2022-07-26T07:02:53.860Z","comments":true,"path":"api/articles/js笔记-2.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（对象）\"><a href=\"#js笔记（对象）\" class=\"headerlink\" title=\"js笔记（对象）\"></a>js笔记（对象）</h1><h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><ol>\n<li>prompt()可以弹出一个提示框，该提示框中会带有一个文本框，用户可以在文本框中输入一段内容，并将内容赋值给变量。</li>\n</ol>\n<hr>\n<h2 id=\"对象的分类\"><a href=\"#对象的分类\" class=\"headerlink\" title=\"对象的分类\"></a>对象的分类</h2><ol>\n<li>内建对象<ol>\n<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用</li>\n<li>比如：Math String Number Boolean Function Object..</li>\n</ol>\n</li>\n<li>宿主对象<ol>\n<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</li>\n<li>比如：BOM DOM</li>\n</ol>\n</li>\n<li>自定义对象<ol>\n<li>由开发人员自己创建的对象</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ol>\n<li>var obj &#x3D; new Object();<ol>\n<li>使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数</li>\n<li>使用typeof检查一个对象时，会返回object</li>\n<li>在对象中保存的值称为属性</li>\n</ol>\n</li>\n<li>向对象中添加属性<ol>\n<li>语法：对象.属性名 &#x3D; 属性值</li>\n</ol>\n</li>\n<li>读取对象中的属性<ol>\n<li>语法：对象.属性名</li>\n<li><em>如果读取对象中没有的属性，不会报错而是会返回undefined</em></li>\n</ol>\n</li>\n<li>修改对象的属性值<ol>\n<li>语法：对象.属性名 &#x3D; 新值</li>\n</ol>\n</li>\n<li>删除对象的属性<ol>\n<li>语法：delete 对象.属性名</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"属性名和属性值\"><a href=\"#属性名和属性值\" class=\"headerlink\" title=\"属性名和属性值\"></a>属性名和属性值</h2><ol>\n<li>属性名<ol>\n<li>对象的属性名不强制要求遵守标识符的规范</li>\n<li>如果要使用特殊的属性名，不能采用.的方式来操作。语法：对象[“属性名”] &#x3D; 属性值</li>\n<li>使用[]这种形式去操作属性更加灵活，在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性</li>\n</ol>\n</li>\n<li>属性值<ol>\n<li>JS对象的属性值可以是任意的数据类型，甚至也可以是object</li>\n<li>in 运算符<ol>\n<li>通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true，没有则返回false</li>\n<li>语法： “属性名”   in   对象</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]},{"title":"js笔记-4（语法）","slug":"js笔记-4","date":"2022-07-16T03:18:12.000Z","updated":"2022-07-26T07:03:11.556Z","comments":true,"path":"api/articles/js笔记-4.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记-语法\"><a href=\"#js笔记-语法\" class=\"headerlink\" title=\"js笔记(语法)\"></a>js笔记(语法)</h1><hr>\n<h2 id=\"创建数组对象\"><a href=\"#创建数组对象\" class=\"headerlink\" title=\"创建数组对象\"></a>创建数组对象</h2><ol>\n<li><p>var arr &#x3D; new Array( );</p>\n</li>\n<li><p>var arr &#x3D; [ ];</p>\n</li>\n<li><p>四个方法</p>\n<ol>\n<li><p>push()  向数组末尾添加一个或多个元素，并且返回数组的新的长度</p>\n</li>\n<li><p>pop()  删除数组的最后一个元素，并将被删除的元素作为返回值返回</p>\n</li>\n<li><p>unshift()  向数组开头添加一个或多个元素，并且返回新的数组长度</p>\n</li>\n<li><p>shift()  删除数组的第一个元素，并将被删除的元素作为返回值返回</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><ol>\n<li><p>forEach()方法需要一个函数作为参数</p>\n</li>\n<li><p>像这种函数，由我们创建但不是由我们调用，我们称为回调函数</p>\n</li>\n<li><p>数组中有几个元素函数就会执行几次，每次执行时，浏览器都会将遍历到的元素以实参的形式传递进来，我们可以来定义实参，来读取这些内容</p>\n</li>\n<li><p>浏览器会在回调函数中传递三个参数</p>\n<ol>\n<li><p>第一个参数，就是当前正在遍历的元素</p>\n</li>\n<li><p>第二个参数，就是当前正在遍历的元素的索引</p>\n</li>\n<li><p>第三个参数，就是正在遍历的数组</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"slice-和splice\"><a href=\"#slice-和splice\" class=\"headerlink\" title=\"slice()和splice()\"></a>slice()和splice()</h2><ol>\n<li><p>slice()</p>\n<ol>\n<li><p>可以用来从数组提取指定元素</p>\n</li>\n<li><p>该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</p>\n</li>\n<li><p>参数</p>\n<ol>\n<li><p>截取开始的位置的索引，包含开始索引</p>\n</li>\n<li><p>截取结束的位置的索引，不包含结束索引</p>\n</li>\n</ol>\n</li>\n<li><p>索引 可以传递一个负值，如果传递一个负值，则从后往前计算</p>\n</li>\n</ol>\n</li>\n<li><p>splice()</p>\n<ol>\n<li><p>可以用于删除数组中的制定元素</p>\n</li>\n<li><p>使用splice()会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回</p>\n</li>\n<li><p>参数</p>\n<ol>\n<li><p>第一个，表示开始位置的索引</p>\n</li>\n<li><p>第二个，表示删除的数量</p>\n</li>\n<li><p>第三个及以后，可以传递一些新的元素，这些元素会自动插入到开始位置索引前边</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"剩余语法\"><a href=\"#剩余语法\" class=\"headerlink\" title=\"剩余语法\"></a>剩余语法</h2><ol>\n<li><p>concat()</p>\n<ol>\n<li><p>concat()可以连接两个或多个数组，并将新的数组返回</p>\n</li>\n<li><p>该方法不会对原数组产生影响</p>\n</li>\n</ol>\n</li>\n<li><p>join()</p>\n<ol>\n<li><p>join()可以将数组转换成一个字符串</p>\n</li>\n<li><p>该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回</p>\n</li>\n<li><p>在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符。<em>如果不指定连接符，则默认使用‘，’作为连接符</em></p>\n</li>\n</ol>\n</li>\n<li><p>reverse()</p>\n<ol>\n<li><p>reverse()可以用来反转数组</p>\n</li>\n<li><p>该方法会直接修改原数组</p>\n</li>\n</ol>\n</li>\n<li><p>sort()</p>\n<ol>\n<li><p>sort()可以用来对数组中的元素进行排序</p>\n</li>\n<li><p>也会影响原数组，默认会按照Unicode编码进行排序（对于纯数字也如此）</p>\n</li>\n<li><p>我们可以自己来指定排序的规则</p>\n<ol>\n<li><p>我们可以在sort()添加一个回调函数，来指定排序规则</p>\n</li>\n<li><p>回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数</p>\n</li>\n<li><p>浏览器会根据回调函数的返回值来决定元素的顺序</p>\n<ol>\n<li><p>如果返回一个大于0的值，则元素会交换位置</p>\n</li>\n<li><p>如果返回一个小于0的值，则不会交换位置</p>\n</li>\n<li><p>如果返回一个0，也不会交换位置</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"call-和apply\"><a href=\"#call-和apply\" class=\"headerlink\" title=\"call()和apply()\"></a>call()和apply()</h2><ol>\n<li><p>call()和apply()</p>\n<ol>\n<li><p>这两个方法都是函数对象的方法，需要通过函数对象来调用</p>\n</li>\n<li><p>当对函数调用call()和apply()都会调用函数执行</p>\n</li>\n<li><p>在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行的this</p>\n</li>\n</ol>\n</li>\n<li><p>call()和apply()的区别</p>\n<ol>\n<li><p>call()方法可以将实参在对象之后依次传递</p>\n</li>\n<li><p>apply()方法需要将实参封装到一个数组中统一传递</p>\n</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]},{"title":"js笔记-6（DOM）","slug":"js笔记-6","date":"2022-07-22T08:47:57.000Z","updated":"2022-07-26T07:03:29.382Z","comments":true,"path":"api/articles/js笔记-6.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（DOM）\"><a href=\"#js笔记（DOM）\" class=\"headerlink\" title=\"js笔记（DOM）\"></a>js笔记（DOM）</h1><hr>\n<h2 id=\"DOM的一些方法\"><a href=\"#DOM的一些方法\" class=\"headerlink\" title=\"DOM的一些方法\"></a>DOM的一些方法</h2><ol>\n<li><p>body</p>\n<ol>\n<li><p>在document中有一个属性body，他保存的是body的引用</p>\n</li>\n<li><p>document.documentElement保存的是html根标签</p>\n</li>\n<li><p>document.all代表页面中所有的元素</p>\n</li>\n</ol>\n</li>\n<li><p>querySelector()</p>\n<ol>\n<li><p>需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象</p>\n</li>\n<li><p>使用该方法总会返回唯一的元素，如果满足条件的元素有多个，则只会返回第一个</p>\n</li>\n</ol>\n</li>\n<li><p>querySelectorAll()</p>\n<ol>\n<li><p>与querySelector()类似，不同的是他会将符合条件的元素封装到一个数组中返回</p>\n</li>\n<li><p>即使符合条件的元素只有一个，他也会返回数组</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"DOM的增删改\"><a href=\"#DOM的增删改\" class=\"headerlink\" title=\"DOM的增删改\"></a>DOM的增删改</h2><ol>\n<li><p>document.createElement( )</p>\n<ol>\n<li><p>可以用于创建一个<strong>元素节点</strong>对象</p>\n</li>\n<li><p>他需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回。</p>\n</li>\n</ol>\n</li>\n<li><p>document.createTextNode( )</p>\n<ol>\n<li><p>可以用来创建一个<strong>文本节点</strong>对象</p>\n</li>\n<li><p>需要一个文本内容作为参数，将会根据改内容创建文本节点，并将新的节点返回</p>\n</li>\n</ol>\n</li>\n<li><p>appendChild( )</p>\n<ol>\n<li><p>向父节点中添加一个新的子节点</p>\n</li>\n<li><p>语法： 父节点.appendChild(子节点);</p>\n</li>\n</ol>\n</li>\n<li><p>insertBefore( )</p>\n<ol>\n<li><p>可以在指定的子节点前插入新的子节点</p>\n</li>\n<li><p>语法： 父节点.insertBefore(新节点，旧节点);</p>\n</li>\n</ol>\n</li>\n<li><p>replaceChild( )</p>\n<ol>\n<li><p>可以用新的节点替换旧节点</p>\n</li>\n<li><p>语法：父节点.replaceChild(新节点，旧节点);</p>\n</li>\n</ol>\n</li>\n<li><p>removeChild( )</p>\n<ol>\n<li><p>可以删除一个子节点</p>\n</li>\n<li><p>语法： 父节点.removeChild(子节点);</p>\n</li>\n<li><p>自删语法： 子节点.parentNode.removeChild(子节点);</p>\n</li>\n</ol>\n</li>\n<li><p>使用innerHTML也可以完成DOM的增删改的相关操作</p>\n<ol>\n<li>一般我们会两种方式结合使用</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]},{"title":"js笔记-7（操作样式的语法）","slug":"js笔记-7","date":"2022-07-23T06:49:12.000Z","updated":"2022-07-26T07:03:39.596Z","comments":true,"path":"api/articles/js笔记-7.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（操作样式的语法）\"><a href=\"#js笔记（操作样式的语法）\" class=\"headerlink\" title=\"js笔记（操作样式的语法）\"></a>js笔记（操作样式的语法）</h1><hr>\n<h1 id=\"操作内联样式\"><a href=\"#操作内联样式\" class=\"headerlink\" title=\"操作内联样式\"></a>操作内联样式</h1><ol>\n<li><p>通过JS修改元素的样式</p>\n<ol>\n<li><p>语法： 元素.style.样式名 &#x3D; 样式值</p>\n</li>\n<li><p>样式值需要用双引号“ ” 引住</p>\n</li>\n<li><p>注意：如果CSS的样式名中含有 - ，这种名称在JS中是不合法的，需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写</p>\n</li>\n<li><p>通过style属性设置的样式都是内联样式，内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示</p>\n</li>\n<li><p>但是如果在样式中写了!important，则此时样式会有最高的优先级，此时会导致JS修改样式失败</p>\n</li>\n</ol>\n</li>\n<li><p>读取CSS的样式</p>\n<ol>\n<li><p>语法： 元素.style.样式名</p>\n<ol>\n<li>通过style属性设置和读取的都是内联样式</li>\n</ol>\n</li>\n<li><p>语法： 元素.currentStyle.样式名</p>\n<ol>\n<li>可以用来读取当前元素正在显示的样式</li>\n</ol>\n</li>\n<li><p>getComputedStyle( )</p>\n<ol>\n<li><p>getComputedStyle( )这个方法来获取元素当前的样式</p>\n</li>\n<li><p>需要两个参数，第一个为要获取的元素，第二个可以传递一个伪元素，一般用null</p>\n</li>\n<li><p>该方法会返回一个对象，对象中封装了当前元素对应的样式</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"其他样式相关的属性\"><a href=\"#其他样式相关的属性\" class=\"headerlink\" title=\"其他样式相关的属性\"></a>其他样式相关的属性</h2><ol>\n<li><p>clientWidth与clientHeight</p>\n<ol>\n<li><p>这两个属性可以获取元素的可见宽度和高度</p>\n</li>\n<li><p>返回值都是不带px的，返回的是一个数字，可以直接进行计算</p>\n</li>\n<li><p>会获取元素宽度和高度，包括内容区和内边距</p>\n</li>\n<li><p>都是只读属性，不能进行修改</p>\n</li>\n</ol>\n</li>\n<li><p>offsetWidth与offsetHeight</p>\n<ol>\n<li>与clientWidth类似，但获取元素的整个宽度和高度，包括内容区、内边距和边框</li>\n</ol>\n</li>\n<li><p>offsetParent</p>\n<ol>\n<li><p>可以用来获取当前元素的定位父元素</p>\n</li>\n<li><p>会获取到离当前元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，则返回body</p>\n</li>\n</ol>\n</li>\n<li><p>offsetLeft与offsetRight</p>\n<ol>\n<li>返回元素的 水平&#x2F;垂直 偏移位置</li>\n</ol>\n</li>\n<li><p>scrollWidth与scrollHeight</p>\n<ol>\n<li>可以获取元素整个滚动区域的 宽度&#x2F;高度</li>\n</ol>\n</li>\n<li><p>scrollLeft与scrollTop</p>\n<ol>\n<li>可以获取 水平&#x2F;垂直 滚动条的距离</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]},{"title":"js笔记-5（正则表达式）","slug":"js笔记-5","date":"2022-07-17T03:19:30.000Z","updated":"2022-07-26T07:03:20.768Z","comments":true,"path":"api/articles/js笔记-5.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"js笔记（正则表达式）\"><a href=\"#js笔记（正则表达式）\" class=\"headerlink\" title=\"js笔记（正则表达式）\"></a>js笔记（正则表达式）</h1><hr>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><ol>\n<li><p>创建正则表达式的方法</p>\n<ol>\n<li><p>语法： var 变量 &#x3D; new RegExp(“正则表达式”,”匹配模式”);</p>\n</li>\n<li><p>可以检查一个字符串中是否含有正则表达式</p>\n</li>\n<li><p>在构造函数中可以传递一个匹配模式作为第二个参数</p>\n<ol>\n<li><p>i 忽略大小写</p>\n</li>\n<li><p>g 全局匹配模式</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>正则表达式的方法：</p>\n<ol>\n<li><p>test( )</p>\n</li>\n<li><p>使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"正则表达式语法\"><a href=\"#正则表达式语法\" class=\"headerlink\" title=\"正则表达式语法\"></a>正则表达式语法</h2><ol>\n<li><p>使用字面量来创建正则表达式</p>\n<ol>\n<li>语法： var 变量 &#x3D; &#x2F;正则表达式&#x2F;匹配模式</li>\n</ol>\n</li>\n<li><p>使用 | 表示或者的意思</p>\n</li>\n<li><p>[]里面的内容也是或的关系</p>\n</li>\n<li><p>可以用[A-z]表示所有字母</p>\n</li>\n<li><p>[0-9]任意数字</p>\n</li>\n<li><p>[^ ]除了</p>\n</li>\n</ol>\n<h2 id=\"正则表达式相关方法\"><a href=\"#正则表达式相关方法\" class=\"headerlink\" title=\"正则表达式相关方法\"></a>正则表达式相关方法</h2><ol>\n<li><p>split()</p>\n<ol>\n<li><p>split()可以将一个字符串拆分为一个数组</p>\n</li>\n<li><p>可以使用正则表达式进行拆分</p>\n</li>\n</ol>\n</li>\n<li><p>search()</p>\n<ol>\n<li><p>search()可以搜索字符串中是否含有指定内容。如果搜索到指定内容，则会返回第一次出现的索引，没有找到则返回-1</p>\n</li>\n<li><p>可以使用正则表达式进行检索</p>\n</li>\n</ol>\n</li>\n<li><p>match()</p>\n<ol>\n<li><p>match()可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</p>\n</li>\n<li><p>默认情况下我们的match只会找到第一个符合要求的内容，找到以后就会停止检索</p>\n<ol>\n<li>我们可以设置正则表达式为全局匹配模式，这样就可以匹配到所有内容</li>\n</ol>\n</li>\n<li><p>match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</p>\n</li>\n</ol>\n</li>\n<li><p>replace()</p>\n<ol>\n<li><p>replace()可以将字符串中指定内容替换为新的内容</p>\n</li>\n<li><p>参数：</p>\n<ol>\n<li><p>被替换的内容，可以接受一个正则表达式作为参数</p>\n</li>\n<li><p>新的内容</p>\n</li>\n</ol>\n</li>\n<li><p>默认只会替换第一个</p>\n</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"正则表达式相关语法\"><a href=\"#正则表达式相关语法\" class=\"headerlink\" title=\"正则表达式相关语法\"></a>正则表达式相关语法</h2><ol>\n<li><p>量词</p>\n<ol>\n<li><p>通过量词可以设置一个内容出现的次数</p>\n</li>\n<li><p>量词只对它前面的内容起作用，可以用括号将多个内容合起来</p>\n</li>\n<li><p>{n} 正好出现n次</p>\n</li>\n<li><p>{m,n} 出现m-n次</p>\n</li>\n<li><p>{m,}  出现m次以上</p>\n</li>\n<li><p>+ 至少一个，相当于{1,}</p>\n</li>\n<li><p>* 0个或多个，相当于{0,}</p>\n</li>\n<li><p>？ 0个或一个，相当于{0,1}</p>\n</li>\n</ol>\n</li>\n<li><p>特定开头或结尾</p>\n<ol>\n<li><p>^ 表示开头，例：reg &#x3D; &#x2F;^a&#x2F;;</p>\n</li>\n<li><p>$ 表示结尾，例：reg &#x3D; &#x2F;a$&#x2F;;</p>\n</li>\n<li><p>如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</p>\n</li>\n</ol>\n</li>\n<li><p>. 表示任意字符</p>\n<ol>\n<li><p>在正则表达式中使用 \\ 作为转义字符 \\. 来表示 .</p>\n</li>\n<li><p>\\w 表示任意字母、数字、_</p>\n</li>\n<li><p>\\W 除了字母、数字、_</p>\n</li>\n<li><p>\\d 任意的数字[0-9]</p>\n</li>\n<li><p>\\D 除了数字</p>\n</li>\n<li><p>\\s 空格</p>\n</li>\n<li><p>\\S 除了空格</p>\n</li>\n<li><p>\\b 单词边界</p>\n</li>\n<li><p>\\B 除了单词边界</p>\n</li>\n</ol>\n</li>\n</ol>\n","link":"","raw":null,"photos":[],"categories":[{"name":"笔记","slug":"笔记","count":7,"path":"api/categories/笔记.json"},{"name":"js笔记","slug":"笔记/js笔记","count":7,"path":"api/categories/笔记/js笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":7,"path":"api/tags/笔记.json"}]}]}